# ОБЪЯСНЕНИЕ АЛГОРИТМА
### 1. Формат входного файла.
Мы предполагаем, что входной файл содержит симплекс‑таблицу в следующем формате:
– Первая строка — целевая функция (строка оценок; коэффициенты целевой функции записаны слева, а правый член — в последнем столбце).
– Остальные строки — ограничения задачи.

Например, входной файл
```
1  1  1  1  4
2  2 -1  1  2
1 -1  2 -1  4
```
интерпретируется так, что первая строка — строка целевой функции, а две оставшиеся – ограничения.

### 2. Выбор базиса.
В данной реализации мы автоматически считаем, что в исходной симплекс‑таблице базисные переменные — это те, которые 
занимают последние m столбцов (где m — число ограничений).
Пусть общее число переменных равно n (без учета свободного члена, то есть число столбцов минус один), а число 
ограничений m. Тогда базис задаётся как список индексов:
```
basic_indices = list(range(n - m, n))
```
При этом мы предполагаем, что соответствующие столбцы в строках ограничений образуют единичную матрицу.

### 3. Двойственный симплекс‑метод.
Метод работает при условии, что текущее решение ­– ДУАЛЬНО допустимо (то есть в строке целевой функции все 
«редуцированные затраты» неотрицательны), но ПРЯМО допустимо оно может быть нарушено (то есть хотя бы один правый 
член ограничения меньше нуля).
Алгоритм:
Пока существует строка ограничения с отрицательным правым членом (b < 0):
1. **Выбор строки.** Выбирается строка r с наименьшим (наиболее отрицательным) b.
2. **Выбор столбца для входа в базис.** Среди столбцов, для которых коэффициент a[r][j] < 0, вычисляется отношение
```
ratio = (c_j) / (-a_rj),
где c_j - коэффициент в строке целевой функции
```
выбирается столбец j с минимальным ratio. Если ни для одного j a[r][j] не отрицательно, задача не имеет допустимых решений.
3. Выполняется поворот (pivot): строка r делится на опорный элемент, а затем из всех остальных строк вычитается нужная 
кратная опорной строке, чтобы в столбце j получился ноль.
4. Обновляется список базисных переменных – переменная j становится базисной для строки r.

После завершения итераций получаем оптимальное решение.

### 4. Обработка бесконечного числа оптимальных решений.
Если после оптимизации существует хотя бы один не-базисный столбец j с нулевым «редуцированным затратом» 
(то есть c[j] == 0), то существует бесконечное число оптимальных решений. Тогда программа дополнительно пытается найти 
альтернативное оптимальное решение путём искусственного поворота (при сохранении оптимальности). Для простоты приведена 
реализация, которая, если находит хотя бы один такой столбец, пытается сделать дополнительный поворот и получает второе решение.

### 5. Работа с дробями.
Все арифметические действия выполняются с использованием класса дробей Fraction из предыдущих работ
(с незначительными изменениями – код интегрирован в один файл).

---

# ПОЯСНЕНИЕ АЛГОРИТМА (ПО ШАГАМ)
### 1. Чтение таблицы.
Функция read_tableau открывает файл (например, input.txt), считывает каждую строку, разбивает её по пробелам и преобразует 
каждое число в объект Fraction. Первая строка считается строкой целевой функции, а остальные – ограничениями.

### 2. Начальный базис.
Мы автоматически выбираем базис, считая, что базисные переменные – это те, что занимают последние m столбцов таблицы 
(где m – число ограничений). Для примера: если всего 4 переменных и 2 ограничения, базис будет [2, 3].

### 3. Двойственный симплекс.
Функция dual_simplex ищет среди строк ограничений те, у которых правый член (столбец свободных членов) отрицательный. 
Для такой строки выбирается столбец с отрицательным коэффициентом, для которого отношение коэффициента строки целевой функции 
к модулю этого отрицательного элемента минимально. Если ни одного подходящего столбца нет, задача не имеет допустимого решения. 
В противном случае выполняется поворот (функция pivot), который приводит таблицу к новому базису. 
Этапы повторяются, пока все ограничения не будут удовлетворены (т.е. все b ≥ 0).

### 4. Извлечение решения.
После завершения метода функция extract_solution строит вектор решения: для базисных переменных их значения – это правые 
члены соответствующих ограничений, а для не-базисных переменные равны 0. Оптимальное значение целевой функции находится 
в правом нижнем углу строки целевой функции.

### 5. Альтернативное решение.
Если после оптимизации оказывается, что есть не‑базисный столбец с нулевым коэффициентом в строке целевой функции, 
функция find_alternative_solution пытается выполнить дополнительный поворот для получения второго оптимального решения. 
Если поворот возможен, выводится альтернативное решение.

---

# ТЕСТИРОВАНИЕ
В этой реализации таблица симплекс‑метода должна быть подготовлена в каноническом виде для двойственного симплекс‑метода, то есть:
– Первая строка — строка целевой функции (коэффициенты при переменных и свободный член в конце).
– Последующие строки — строки ограничений.
– Количество переменных (без свободного члена) равно числу столбцов минус один, а число ограничений равно числу строк минус один.
– Программа сама выбирает стартовый базис, предполагая, что базисные переменные соответствуют последним m столбцам.

### ТЕСТ 1. Ситуация «оптимальное решение уже найдено»
##### Входной файл: test1.txt
##### Пояснение:
В этой таблице:
- Первая строка — строка целевой функции.
- Две следующие строки – ограничения. 

Начальный базис вычисляется как последние 2 столбца (так как m = 2 и общее число переменных n = 4, базис = [2, 3]).
При проверке правых частей в ограничениях (b = 2 и b = 4) отрицательных значений нет, поэтому поворотов не производится.

### ТЕСТ 2. Ситуация «двойственная неразрешимость» (нет допустимого решения)
##### Входной файл: test2.txt
##### Пояснение
Здесь всего одна строка ограничения. Поскольку общее число столбцов = 4 (n+1), получаем число переменных n = 3 и m = 1, 
базис по умолчанию будет равен [ (3-1)=2 ], то есть базис – переменная с индексом 2. В строке ограничения свободный член 
равен –5 (отрицательный), но все коэффициенты в этой строке равны 0 (то есть ни один из них не меньше 0 – нет 
«отрицательного» элемента, который можно использовать для поворота). Это означает, что правила двойственного 
симплекс‑метода не позволяют получить допустимое решение.

### ТЕСТ 3. Ситуация с проведением поворота (двойственный симплекс применяется)
##### Входной файл: test3.txt
##### Пояснение.
– Всего переменных n = 4 (без свободного члена) и m = 2, поэтому базис по умолчанию = [2, 3].
– В первой строке ограничения (строка с индексом 1) свободный член равен –2, что является нарушением прямой допустимости.

Алгоритм работает так:
1. Выбирается строка 1 (так как –2 самое отрицательное).
2. В этой строке смотрятся коэффициенты: [1, –1, 0, 0]. Единственный кандидат для поворота – столбец 1 (так как –1 < 0).
3. Вычисляется отношение: ratio = c[1] / (– (–1)) = 2/1 = 2.
4. Выполняется поворот с pivot_row = 1 и pivot_col = 1.

После поворота базис обновляется:
- Для строки 1 базисная переменная становится с индексом 1.
- Решение извлекается следующим образом:
  * Переменная с индексом 1 получает значение из строки 1 (последнее число после поворота).
  * Переменная с индексом 3 остаётся в базисе из строки 2.

При ручном просчёте получаем итоговое решение:
- x1 = 0
- x2 = 2
- x3 = 0
- x4 = 3
- Оптимальное значение целевой функции = 6.

### ТЕСТ 4. Ситуация с альтернативным оптимальным решением
##### Входной файл: test4.txt
##### Пояснение
Для демонстрации альтернативных решений необходимо, чтобы в оптимальном состоянии нашлась не-базисная переменная, у которой 
коэффициент в строке целевой функции равен 0, и чтобы при попытке поворота по ней сохранялась допустимость.

* Всего переменных n = 4 и m = 2, базис по умолчанию = [2, 3].
* Строка целевой функции (первая строка) задаёт коэффициенты:
  — Для переменной x1: 0 (то есть редуцированная стоимость равна 0).
  — Для остальных: 1 и 2, соответственно.
* Извлекаемое оптимальное решение (исходное) будет таким:
— По базису: x3 = значение из второй строки = 4, x4 = значение из третьей строки = 4, остальные — 0, что даёт оптимальное 
значение 8.
* При проверке альтернативных решений функция ищет не-базисный столбец с коэффициентом 0 в строке целевой функции. 
Здесь это переменная с индексом 0 (x1).
* Далее берётся первая строка ограничения, в которой коэффициент при x1 ≠ 0 (для строки 2: коэффициент равен 3). 
Поворот по этому элементу приводит к новому базису, в котором базис заменяется – альтернативное решение.

Пошаговый расчёт альтернативного решения (проводится внутри функции find_alternative_solution):
1. Поворот по строке 1 (вторая строка исходной таблицы) по столбцу 0.
2. После деления строки 1 на pivot-элемент (3) строка становится:
[1, 2/3, 1/3, 0, 4/3].
3. Обновление остальных строк:
– Строка 0 остаётся без изменений (так как её элемент в столбце 0 равен 0).
– Строка 2: обновляется, вычитая 1 * новую строку 1:
[1 - 1, -1 - 2/3, 0 - 1/3, 1 - 0, 4 - 4/3] = [0, -5/3, -1/3, 1, 8/3].
4. Новый базис: для строки 1 теперь переменная x1 (индекс 0), для строки 2 – остаётся переменная x4 (индекс 3).
5. Извлекаем альтернативное решение:
– x1 = 4/3
– x4 = 8/3
– x2 и x3 = 0
- При этом оптимальное значение (из строки целевой функции) остаётся 8.
